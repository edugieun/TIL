# 알고리즘

문제 풀 때 라이브러리 사용하지 않는다.

- ##### max(), min(), indexof(), sort(), slicing 등

- ##### 대신, append, len 같은 건 써도 됨.

- #### 시간 복잡도(Time Complexity)

  - ##### 알고리즘의 작업량을 표현

  - ##### 실제 걸리는 시간과 실행되는 명령문 개수를 계산

  - #### 빅-오(O) 표기법(Big-Oh Notation)

    - ##### 최고차 항의 차수만으로 비교.

    - ##### 최악의 경우

      - ##### n 번 모두 확인해야하는 법 -> 유한하므로 시간 복잡도 계산하기에 적합

  - ##### 오메가 표기법

    - ##### 최선의 경우

      - ##### 한 번에 찾아낼 경우

  - ##### 세타 표기법

    - ##### 최악=최선일 경우

- ##### 이진탐색

  - ##### List가 정렬되어 있어야 함.

  - ##### 중간 값을 비교한 후에, 중간 값을 기준으로 필요 없는 한 쪽은 버린다.

  - ##### 100만 개는 10<sup>20</sup> 이고, 원하는 값은 20번만에 찾을 수 있다.



## 정렬

- #### 버블 정렬(Bubble Sort)

  - ##### 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식

    ```python
    # Bubble sort
    arr = [55, 7, 78, 12, 42]
    n = len(arr)
    # 2. n-1 부터 1까지 전체 반복
    for j in range(n - 1, 0, -1):
    	# 1. 처음부터 끝까지 1회 비교
        for i in range(n - 1):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
    ```

- #### 선택 정렬(Selection Sort)

  - ##### 최소값을 찾아 맨 앞으로 옮김

    ```python
    arr = [55, 7, 78, 12, 42]
    # 1. 처음 수로 초기 설정
    MIN = 0
    
    # 3. 2번을 idx:[0]~[n-2]까지 반복 (마지막[n-1]은 자동)
    for j in range(len(arr) - 1):
        MIN = j
        # 2. 처음부터 끝까지 보면서 가장 작은 수 맨 앞으로.
        for i in range(1, len(arr)):
            if arr[i] < arr[MIN]:
        		MIN = i
                
        arr[j], arr[MIN] = arr[MIN], arr[j]
    ```

    

- #### 카운팅 정렬(Counting Sort)??

  - ##### 각 항목의 개수를 세서 정렬

  - ##### 누적 빈도수를 이용??

    ```python
    data = [0, 3, 1, 3, 1, 2, 4, 1]
    counts = [0] * 5 
    
    for val in data:
        counts[val] += 1
        
    sorted = []
    for i in range(len(counts)):
        for j in range(counts[i]):
            sorted.append(i)
            ???
    ```

    

## 배열 연습 문제

- #### Gravity

  <img src = "https://user-images.githubusercontent.com/52814897/62027223-1dc63900-b218-11e9-899c-d9c942abcc71.png" style="zoom:60%" />

  <img src = "https://user-images.githubusercontent.com/52814897/62027242-2585dd80-b218-11e9-9cbd-7e1a7bd8a4d8.png" style="zoom:60%" />

  

  

  ```python
  # Gravity
  ```

  

- #### Baby-gin Game

<img src = "https://user-images.githubusercontent.com/52814897/62027556-edcb6580-b218-11e9-8f85-d3b9cb2184f0.png" style = "zoom:60%" />

<img src="https://user-images.githubusercontent.com/52814897/62027569-f4f27380-b218-11e9-9980-bec0bc251100.png" style="zoom:60%" />

```python
data = 'ABC'

n = len(data)
for i in range(n):
    for j in range(n):
        if i == j: continue
        for k in range(n):
            if i == k or j == k: continue
            print(data[i], data[j], data[k])
```



- #### 최적화 문제 -> 완전 검색

  - ##### 최대 혹은 최소가 되는 경우를 찾는 문제
  
  - ##### 모든 가능한 경우를 조사한다. 
  
  - ##### 모든 후보해를 조사한다.
  
  - ##### 모든 가능한 경우들이 조합과 관련이 깊다.
  
    - ##### 순열, 부분집합, 조합, n!, 2^n
  
- #### 완전 검색을 좀 더 효율적으로 하는 방법

  1. ##### 백트래킹(가지치기)

  2. ##### 동적 계획법(메모이제이션)



## 배열 2

- ### 부분집합

  ```python
  arr = [3, 6, 7, 1, 5, 4]
  
  n = len(arr) # n: 원소의 개수
  
  for i in range(1 << n): # 1<<n: 부분 집합의 개수
      for j in range(n+1): # 원소의 수만큼 비트를 비교함
          if i & (1 << j): # i의 j번째 비트가 1이면 j번째 원소 출력
              print(arr[j], end=", ")
          print()
      print()
  ```




## 문자열

### 문자열

- ASCII: 문자 인코딩 표준

- `print(ord('A'))` 로 A에 대한 ASCII 코드 값을 알 수 있다.

- `print(chr(65))`로 65에 ASCII 코드 값에 해당하는 문자를 알 수 있다.

- ![image](https://user-images.githubusercontent.com/52814897/62843619-275e9f00-bcf6-11e9-9eb0-149e322f9e31.png)

- 유니코드(UTF): 다국어 처리를 위한 표준

- 문자열 뒤집기

  - ```python
    ## 문자열 뒤집기
    # 1. Slicing 사용
    arr = 'algorithm'
    print(arr[::-1])
    # 2. 교환 방식
    arr = list(arr)
    n = len(arr)
    for i in range(n//2):
        #arr[i] <-> arr[n- 1 - i]
        arr[i], arr[n - 1 - i] = arr[n - 1 - i], arr[i]
    print(''.join(arr))
    ```

- 문자열 숫자를 정수형으로 변환

  - ```python
    ## 문자열 숫자를 정수로 변환
    # 1. ASCII 활용
    arr = '12345'
    val = 0
    for i in arr:
        val = val * 10 + ord(i) - ord('0')
    # 2. 내장함수
    int(arr)
    ```

### 패턴 매칭

- 고지식한 알고리즘(Brute Foce)
- KMP 알고리즘
- 보이어-무어 알고리즘
  - 텍스트의 용량이 클 때 좋음.

### 문자열 암호화

### 문자열 압축

### 실습 1, 2