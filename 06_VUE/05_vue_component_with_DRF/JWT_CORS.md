Vue가 Django에 요청을 보낼 때는 항상 JWT 필요

JWT: 정보를 안전하게 JSON 객체로 전송하기 위한 간결하고 독립적인 방법

- 세션/쿠키와 함께 모바일과 웹의 인증을 책임지는 대표 기술 중 하나.
- 세션/쿠키의 정보 전달 방식과 유사하게 사용자는 Access Token(JWT Token)을 HTTP header에 실어서 서버로 요청을 보낸다.
- 세션/쿠기 방식과의 가장 큰 차이점은 세션/쿠키는 세션 저장소에 유저의 정보를 넣지만, JWT는 토큰 안에 유저의 정보를 넣는다.(즉, 서버측에 유저정보를 저장하지 않는다./서버에 부하가 걸리지 않는다.)
- Client 의 입장에서는 HTTP header에 세션 ID와 토큰을 실어서 보낸다는 점은 동일하지만, Server의 입장에서는 인증을 위해 암호화ajaxJWT)를 하냐 혹은 별도의 저장소(세션/쿠키 방식)을 이용하느냐의 차이

 https://jwt.io/ 

JWT를 어디에 써?

1. 회원 인증(Authorization)
   - 서버가 유저 정보에 기반한 토큰(JWT)을 발급해 유저에게 전달하고, 유저는 서버에 요청을 보낼때마다 JWT를 포함하여 전달한다.
   - 서버는 세션을 유지할 필요 없이 유저의 요청정보 안에 있는 JWT 만 확인하면 된다. (서버 자원을 아낄 수 있다.)
2. 정보 교환(Infomation Exchange)
   - 정보가 서명되어 있기 때문에 정보를 보낸 사람의 정보 혹은 정보 조작여부 확인 등이 가능하다.

두 개체(Django와 Vue 뿐만 아니라 서로 다른 프레임워크에서도 사용가능)에서 JSON 객체를 사용하여 가볍고 자가 수용적인(self-contained, 필요한 모든 정보를 자체적으로 지님) 방식으로 정보를 안정성 있게 전달.

세션 상태를 저장하는 것이 아니라 필요한 정보를 JWT에 저장해서 사용자가 가지고 있게 하고, 해당 JWT를 증명서처럼 사용하는 방식

JWT 구조: xxxx.yyyy.zzzz => Header.Payload(내용).Signature

Header: token의 type과 사용 algorithm

Payload: 토큰에 담길 정보가 들어있는 곳(claim - key:value). 3가지 claim이 있다

	1. registered claim: 토큰에 대한 정보들을 담기 위해 이름이 이미 정해진 클레임들. 클레임의 사용은 모두 선택적이다.
 	2. public claim: 공개 클레임은 충돌이 되지  않는 이름을 가지고 있어야 한다. 보통 충돌을 방지하기 위해 key값을 URI 형태로 만든다.(예: https://test.co.kr....)
 	3. private claim: 등록된 클레임, 공개 클레임 둘 다 아님. 클라이언트와 서버간에 협의하에 사용되는 클레임들. (예: 장고에서 필드 값들 같은 것. {"username": "admin"}). key값이 중복되어 충돌이 될 수 있으니 유의해서 사용.

Signature(서명): Header와 Payload의 값에 비밀키로 hasing

- HEADER의 인코딩 값과, PAYLOAD의 인코딩 값을 합친 후 주어진 비밀키로 해쉬를 생성한 값

장점

1. 세션/쿠키처럼 별도의 저장소 관리가 필요 없고 발급한 이후에 검증만 하면 된다.
2. 토큰을 기반으로 한 다른 인증시스템에 접근이 용이하기 때문에 확장성, 이식성이 뛰어나다.
3. 모바일 환경에 적합(쿠키와 같은 데이터로 인증할 필요가 없기 때문)
4. Python, JS, Ruby, Go 등 주류 프로그래밍 언어에서 대부분 지원된다.

단점

1. 이미 발급된 JWT는 유효기간이 완료될 때까지 계속 사용하기 때문에 악용될 가능성이 있다.(한번 발급된 토큰은 값을 수정하거나 폐기할 수 없기 때문에.) 그래서 이 문제는 Access Token의 유효기간(expire time)을 짧게 하고, Refresh Token 등을 이용해서 중간중간 새로운 토큰을 재발행 해준다.
2. 세션/쿠키 방식에 비해 claim 데이터가 많아진다면 JWT 토큰의 길이가 길어지기 때문에 인증 요청이 많아 질수록 네트워크의 대역폭이 낭비될 수 있다.(API 호출 시 매번 헤더에 붙여서 전달하기 때문)

------

## Tag

### router-link

- router 지원 앱에서 사용자 네비게이션을 가능하게 해주는 컴포넌트
- 목표 위치는 `to` prop으로 지정된다.
- 라우팅은 URI에 따라 해당하는 정적 파일을 내려주는 방식인데 이를 브라우저에서 구현하는 것이 SPA개발의 핵심
- `a`태그를 안 쓰는 이유? HTML5 히스토리 모드에서 클릭 이벤트 자체를 차단하여 브라우저가 페이지를 다시 로드하지 않도록 한다.

### router-view

- 라우팅이 경로에 맞는 컴포넌트를 렌더링 해주는 부분.

------

- 기존 App(최상위) <-> components/<하위컴포넌트> 의 구조에서
- 라우터에 의해 App(최상위) - views/<라우터 컴포넌트> - components/<하위컴포넌트> 의 구조로 변경

------

## HTTP 접근 제어 (CORS)

- Cross-Origin Resource Sharing
- 한 도메인에서 로드되어 다른 도메인에 있는 리소스와 상호 작용 하는 것. 즉, 도메인이나 포트가 다른 서버의 자원을 요청하는 **메커니즘**.
- 같은 주소면 상관없지만, 도메인이 다르거나 포트가 다를 경우 보안상의 이유로 서로 요청을 주고받을 수 없다.
- 따라서,  브라우저와 서버 간의 안전한 교차 출처 요청 및 데이터 전송을 위해서는 CORS 처리를 해줘야 한다.

### 문제 상황

1. 요청을 할 때 cross-origin HTTP에 의해 요청을 한다.
2. 하지만 CORS와 같은 상황이 발생하면 외부 서버에 의한 요청 데이터를 브라우저에게 차단하기 때문에(보안 목적) 정상적으로 데이터를 받을 수 없다.
3. 예를 들어, http://localhost:8080/에서 vue를 실행하고, http://localhost:8000/ 에서 Django를 실행할 경우, 도메인은 같을지라도 포트가 달라 다른 도메인으로 인지하고 브라우저가 요청을 차단한다.

### 해결 방법

1. 서버(Django)와 클라이언트(Vue)가 같은 도메인과 포트를 사용하도록 한다.
2. 서버에서 cross-origin HTTP 요청을 허가한다.
   - 실제 API 서버들은 이러한 CORS 제한과 관련된 처리를 모두 해둬야 한다.

![image](https://user-images.githubusercontent.com/52814897/69104747-b5dc7c80-0aac-11ea-9f2a-ca973e49faee.png)

[ https://developer.mozilla.org/ko/docs/Web/HTTP/Access_control_CORS ]